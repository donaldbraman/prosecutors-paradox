{"mappings":"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","sources":["<anon>","simulation.js"],"sourcesContent":["const whiteRateInput = document.getElementById('white_rate');\nconst blackRateInput = document.getElementById('black_rate');\nconst avgFirstInput = document.getElementById('avg_first');\nconst avgSecondInput = document.getElementById('avg_second');\nconst avgThirdInput = document.getElementById('avg_third');\nconst runSimulationButton = document.getElementById('run_simulation');\nconst whiteGrid = document.getElementById('white_grid');\nconst blackGrid = document.getElementById('black_grid');\n// Chart Elements\nconst singleChartCanvas = document.getElementById('single_sim_chart');\nconst multipleChartCanvas = document.getElementById('multiple_sims_chart');\nconst singleChartCtx = singleChartCanvas.getContext('2d');\nconst multipleChartCtx = multipleChartCanvas.getContext('2d');\n// State Variables\nconst gridSize = 10;\nlet whitePeople = [];\nlet blackPeople = [];\nlet singleChart;\nlet multipleChart;\n// Input validation\nfunction validateInputs() {\n    const inputs = [\n        whiteRateInput,\n        blackRateInput,\n        avgFirstInput,\n        avgSecondInput,\n        avgThirdInput\n    ];\n    let isValid = true;\n    inputs.forEach((input)=>{\n        const value = parseFloat(input.value);\n        if (input.id.includes('rate')) {\n            if (value < 0 || value > 100) {\n                input.style.borderColor = 'red';\n                isValid = false;\n            } else input.style.borderColor = '#ccc';\n        } else if (value < 0 || value > 10) {\n            input.style.borderColor = 'red';\n            isValid = false;\n        } else input.style.borderColor = '#ccc';\n    });\n    return isValid;\n}\nfunction initializePeople() {\n    whitePeople = Array.from({\n        length: gridSize * gridSize\n    }, ()=>({\n            arrests: 0,\n            sentenceServed: 0,\n            sentenceRemaining: 0,\n            x: Math.random(),\n            y: Math.random()\n        }));\n    blackPeople = Array.from({\n        length: gridSize * gridSize\n    }, ()=>({\n            arrests: 0,\n            sentenceServed: 0,\n            sentenceRemaining: 0,\n            x: Math.random(),\n            y: Math.random()\n        }));\n}\nfunction drawGrid(gridElement, people, isWhite) {\n    gridElement.innerHTML = '';\n    people.forEach((person)=>{\n        if (person.arrests > 0) {\n            const dot = document.createElement('div');\n            dot.className = `dot ${isWhite ? 'white-dot' : 'black-dot'}`;\n            const baseSize = 8;\n            const dotSize = baseSize + (person.arrests - 1) * 4;\n            dot.style.width = `${dotSize}px`;\n            dot.style.height = `${dotSize}px`;\n            dot.style.left = `${person.x * 100}%`;\n            dot.style.top = `${person.y * 100}%`;\n            gridElement.appendChild(dot);\n        }\n    });\n}\nfunction getSentence(arrestCount) {\n    const avgFirst = parseFloat(avgFirstInput.value);\n    const avgSecond = parseFloat(avgSecondInput.value);\n    const avgThird = parseFloat(avgThirdInput.value);\n    if (arrestCount === 1) return avgFirst;\n    if (arrestCount === 2) return avgSecond;\n    return avgThird;\n}\nfunction simulateArrests(people, arrestRate) {\n    const eligiblePeople = people.filter((person)=>person.sentenceRemaining <= 0);\n    const totalEligible = eligiblePeople.length;\n    const expectedArrests = Math.round(totalEligible * arrestRate);\n    for(let i = 0; i < expectedArrests; i++){\n        if (eligiblePeople.length === 0) break;\n        const randomIndex = Math.floor(Math.random() * eligiblePeople.length);\n        const selectedPerson = eligiblePeople[randomIndex];\n        selectedPerson.arrests++;\n        const sentence = getSentence(selectedPerson.arrests);\n        selectedPerson.sentenceRemaining = sentence;\n        eligiblePeople.splice(randomIndex, 1);\n    }\n}\nfunction updateSentences(people) {\n    people.forEach((person)=>{\n        if (person.sentenceRemaining > 0) {\n            person.sentenceServed++;\n            person.sentenceRemaining--;\n        }\n    });\n}\nfunction getChartOptions(titleText) {\n    return {\n        responsive: true,\n        maintainAspectRatio: false,\n        interaction: {\n            intersect: false,\n            mode: 'index'\n        },\n        plugins: {\n            title: {\n                display: true,\n                text: titleText,\n                padding: {\n                    top: 10,\n                    bottom: 30\n                },\n                font: {\n                    size: 18,\n                    weight: '600',\n                    family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                },\n                color: '#2c3e50'\n            },\n            legend: {\n                position: 'top',\n                align: 'center',\n                labels: {\n                    padding: 25,\n                    usePointStyle: true,\n                    pointStyle: 'circle',\n                    font: {\n                        size: 13,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                }\n            },\n            tooltip: {\n                backgroundColor: 'rgba(255, 255, 255, 0.95)',\n                titleColor: '#2c3e50',\n                titleFont: {\n                    size: 14,\n                    weight: '600',\n                    family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                },\n                bodyColor: '#34495e',\n                bodyFont: {\n                    size: 13,\n                    family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                },\n                borderColor: 'rgba(0,0,0,0.1)',\n                borderWidth: 1,\n                padding: 12,\n                cornerRadius: 6,\n                displayColors: true,\n                boxWidth: 8,\n                boxHeight: 8,\n                callbacks: {\n                    label: (context)=>{\n                        const dataset = context.dataset;\n                        const value = context.parsed.y;\n                        let label = `${dataset.label}: ${value.toFixed(1)} years`;\n                        if (dataset.errorBars && dataset.errorBars.plus) {\n                            const stdDev = dataset.errorBars.plus[context.dataIndex];\n                            if (stdDev > 0) label += ` \\xb1${stdDev.toFixed(1)}`;\n                        }\n                        return label;\n                    }\n                }\n            }\n        },\n        scales: {\n            y: {\n                beginAtZero: true,\n                title: {\n                    display: true,\n                    text: 'Cumulative Sentence Years',\n                    padding: {\n                        top: 15,\n                        bottom: 15\n                    },\n                    font: {\n                        size: 14,\n                        weight: '600',\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                },\n                ticks: {\n                    font: {\n                        size: 12,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#34495e',\n                    padding: 8\n                },\n                grid: {\n                    color: 'rgba(0,0,0,0.05)',\n                    drawBorder: false\n                }\n            },\n            x: {\n                title: {\n                    display: true,\n                    text: 'Simulation Year',\n                    padding: {\n                        top: 15,\n                        bottom: 15\n                    },\n                    font: {\n                        size: 14,\n                        weight: '600',\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                },\n                ticks: {\n                    font: {\n                        size: 12,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#34495e',\n                    padding: 8\n                },\n                grid: {\n                    color: 'rgba(0,0,0,0.05)',\n                    drawBorder: false\n                }\n            }\n        }\n    };\n}\nfunction runSimulation() {\n    if (!validateInputs()) {\n        alert('Please check input values. Arrest rates must be between 0-100%, sentences between 0-10 years.');\n        return;\n    }\n    initializePeople();\n    const whiteRate = parseFloat(whiteRateInput.value) / 100;\n    const blackRate = parseFloat(blackRateInput.value) / 100;\n    let whiteCumulativeSentences = [];\n    let blackCumulativeSentences = [];\n    for(let year = 0; year < 20; year++){\n        simulateArrests(whitePeople, whiteRate);\n        simulateArrests(blackPeople, blackRate);\n        updateSentences(whitePeople);\n        updateSentences(blackPeople);\n        const totalWhiteSentences = whitePeople.reduce((sum, person)=>sum + person.sentenceServed, 0);\n        const totalBlackSentences = blackPeople.reduce((sum, person)=>sum + person.sentenceServed, 0);\n        whiteCumulativeSentences.push(totalWhiteSentences);\n        blackCumulativeSentences.push(totalBlackSentences);\n        drawGrid(whiteGrid, whitePeople, true);\n        drawGrid(blackGrid, blackPeople, false);\n    }\n    renderSingleSimChart(whiteCumulativeSentences, blackCumulativeSentences);\n}\nfunction renderSingleSimChart(whiteData, blackData) {\n    if (singleChart) singleChart.destroy();\n    const labels = Array.from({\n        length: 20\n    }, (_, i)=>`Year ${i + 1}`);\n    singleChart = new Chart(singleChartCtx, {\n        type: 'line',\n        data: {\n            labels: labels,\n            datasets: [\n                {\n                    label: 'White Population',\n                    data: whiteData,\n                    borderColor: '#1976D2',\n                    borderWidth: 2.5,\n                    tension: 0.3,\n                    pointRadius: 4,\n                    pointHoverRadius: 6,\n                    pointBackgroundColor: '#1976D2',\n                    pointBorderColor: '#fff',\n                    pointBorderWidth: 2,\n                    pointHoverBackgroundColor: '#1976D2',\n                    pointHoverBorderColor: '#fff',\n                    pointHoverBorderWidth: 2,\n                    fill: false\n                },\n                {\n                    label: 'Black Population',\n                    data: blackData,\n                    borderColor: '#D32F2F',\n                    borderWidth: 2.5,\n                    tension: 0.3,\n                    pointRadius: 4,\n                    pointHoverRadius: 6,\n                    pointBackgroundColor: '#D32F2F',\n                    pointBorderColor: '#fff',\n                    pointBorderWidth: 2,\n                    pointHoverBackgroundColor: '#D32F2F',\n                    pointHoverBorderColor: '#fff',\n                    pointHoverBorderWidth: 2,\n                    fill: false\n                }\n            ]\n        },\n        options: getChartOptions('Single Simulation Results')\n    });\n}\nfunction calculateStats(simulations) {\n    const timePoints = simulations[0].length;\n    const means = Array(timePoints).fill(0);\n    const stdDevs = Array(timePoints).fill(0);\n    // Calculate means for each time point\n    for(let t = 0; t < timePoints; t++)means[t] = simulations.reduce((sum, sim)=>sum + sim[t], 0) / simulations.length;\n    // Calculate standard deviations for each time point\n    for(let t = 0; t < timePoints; t++){\n        const squaredDiffs = simulations.map((sim)=>Math.pow(sim[t] - means[t], 2));\n        const variance = squaredDiffs.reduce((sum, diff)=>sum + diff, 0) / simulations.length;\n        stdDevs[t] = Math.sqrt(variance);\n    }\n    return {\n        means,\n        stdDevs\n    };\n}\nfunction runMultipleSimulations() {\n    if (!validateInputs()) {\n        alert('Please check input values. Arrest rates must be between 0-100%, sentences between 0-10 years.');\n        return;\n    }\n    const numSimulations = 1000;\n    const whiteSimulations = [];\n    const blackSimulations = [];\n    for(let i = 0; i < numSimulations; i++){\n        initializePeople();\n        const whiteRate = parseFloat(whiteRateInput.value) / 100;\n        const blackRate = parseFloat(blackRateInput.value) / 100;\n        let whiteCumulativeSentences = [];\n        let blackCumulativeSentences = [];\n        for(let year = 0; year < 20; year++){\n            simulateArrests(whitePeople, whiteRate);\n            simulateArrests(blackPeople, blackRate);\n            updateSentences(whitePeople);\n            updateSentences(blackPeople);\n            const totalWhiteSentences = whitePeople.reduce((sum, person)=>sum + person.sentenceServed, 0);\n            const totalBlackSentences = blackPeople.reduce((sum, person)=>sum + person.sentenceServed, 0);\n            whiteCumulativeSentences.push(totalWhiteSentences);\n            blackCumulativeSentences.push(totalBlackSentences);\n        }\n        whiteSimulations.push(whiteCumulativeSentences);\n        blackSimulations.push(blackCumulativeSentences);\n    }\n    const whiteStats = calculateStats(whiteSimulations);\n    const blackStats = calculateStats(blackSimulations);\n    renderMultipleSimsChart(whiteStats, blackStats);\n}\n// Define custom plugin for ratio text\nconst ratioTextPlugin = {\n    id: 'ratioText',\n    beforeDraw: (chart, args, options)=>{\n        const { ctx, chartArea: { left, top, right, bottom } } = chart;\n        if (!options.text) return;\n        // Save context state\n        ctx.save();\n        // Set text style\n        ctx.font = '16px Arial, \"Helvetica Neue\", sans-serif';\n        ctx.fillStyle = '#2c3e50';\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'top';\n        // Calculate position (5% from left, 5% from top)\n        const x = left + (right - left) * 0.05;\n        const y = top + (bottom - top) * 0.05;\n        // Draw background\n        const textLines = options.text.split('\\n');\n        const lineHeight = 28;\n        const padding = 20;\n        const textWidth = Math.max(...textLines.map((line)=>ctx.measureText(line).width));\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n        ctx.fillRect(x - padding, y - padding, textWidth + padding * 2, textLines.length * lineHeight + padding * 2);\n        // Draw text\n        ctx.fillStyle = '#2c3e50';\n        textLines.forEach((line, i)=>{\n            ctx.fillText(line, x, y + i * lineHeight);\n        });\n        // Restore context state\n        ctx.restore();\n    }\n};\n// Register the plugin\nChart.register(ratioTextPlugin);\nfunction renderMultipleSimsChart(whiteStats, blackStats) {\n    if (multipleChart) multipleChart.destroy();\n    const labels = Array.from({\n        length: 20\n    }, (_, i)=>`Year ${i + 1}`);\n    // Calculate black-to-white ratio at year 20\n    const blackToWhiteRatio = blackStats.means[19] / whiteStats.means[19];\n    const ratioText = `For every year a white person spends incarcerated\\nfor criminal conduct, a black person engaging in\\nthe same conduct spends ${blackToWhiteRatio.toFixed(1)} years\\nincarcerated.`;\n    multipleChart = new Chart(multipleChartCtx, {\n        type: 'line',\n        data: {\n            labels: labels,\n            datasets: [\n                {\n                    label: 'White Population',\n                    data: whiteStats.means,\n                    borderColor: '#1976D2',\n                    borderWidth: 2.5,\n                    tension: 0.3,\n                    pointRadius: 4,\n                    pointHoverRadius: 6,\n                    pointBackgroundColor: '#1976D2',\n                    pointBorderColor: '#fff',\n                    pointBorderWidth: 2,\n                    pointHoverBackgroundColor: '#1976D2',\n                    pointHoverBorderColor: '#fff',\n                    pointHoverBorderWidth: 2,\n                    fill: false,\n                    errorBars: {\n                        plus: whiteStats.stdDevs,\n                        minus: whiteStats.stdDevs,\n                        color: 'rgba(25, 118, 210, 0.3)'\n                    }\n                },\n                {\n                    label: 'Black Population',\n                    data: blackStats.means,\n                    borderColor: '#D32F2F',\n                    borderWidth: 2.5,\n                    tension: 0.3,\n                    pointRadius: 4,\n                    pointHoverRadius: 6,\n                    pointBackgroundColor: '#D32F2F',\n                    pointBorderColor: '#fff',\n                    pointHoverBackgroundColor: '#D32F2F',\n                    pointHoverBorderColor: '#fff',\n                    pointHoverBorderWidth: 2,\n                    fill: false,\n                    errorBars: {\n                        plus: blackStats.stdDevs,\n                        minus: blackStats.stdDevs,\n                        color: 'rgba(211, 47, 47, 0.3)'\n                    }\n                }\n            ]\n        },\n        options: {\n            ...getChartOptions('Multiple Simulations Results (with Standard Deviation)'),\n            plugins: {\n                ...getChartOptions('').plugins,\n                ratioText: {\n                    text: ratioText\n                }\n            }\n        }\n    });\n}\n// Add event listeners\nrunSimulationButton.addEventListener('click', ()=>{\n    runSimulation();\n    drawGrid(whiteGrid, whitePeople, true);\n    drawGrid(blackGrid, blackPeople, false);\n});\ndocument.getElementById('run_multiple_simulations').addEventListener('click', ()=>{\n    runMultipleSimulations();\n});\n// Initialize with single simulation\nrunSimulation();\n\n//# sourceMappingURL=index.21f70b48.js.map\n","const whiteRateInput = document.getElementById('white_rate');\nconst blackRateInput = document.getElementById('black_rate');\nconst avgFirstInput = document.getElementById('avg_first');\nconst avgSecondInput = document.getElementById('avg_second');\nconst avgThirdInput = document.getElementById('avg_third');\nconst runSimulationButton = document.getElementById('run_simulation');\nconst whiteGrid = document.getElementById('white_grid');\nconst blackGrid = document.getElementById('black_grid');\n\n// Chart Elements\nconst singleChartCanvas = document.getElementById('single_sim_chart');\nconst multipleChartCanvas = document.getElementById('multiple_sims_chart');\nconst singleChartCtx = singleChartCanvas.getContext('2d');\nconst multipleChartCtx = multipleChartCanvas.getContext('2d');\n\n// State Variables\nconst gridSize = 10;\nlet whitePeople = [];\nlet blackPeople = [];\nlet singleChart;\nlet multipleChart;\n\n// Input validation\nfunction validateInputs() {\n    const inputs = [whiteRateInput, blackRateInput, avgFirstInput, avgSecondInput, avgThirdInput];\n    let isValid = true;\n    inputs.forEach(input => {\n        const value = parseFloat(input.value);\n        if (input.id.includes('rate')) {\n            if (value < 0 || value > 100) {\n                input.style.borderColor = 'red';\n                isValid = false;\n            } else {\n                input.style.borderColor = '#ccc';\n            }\n        } else {\n            if (value < 0 || value > 10) {\n                input.style.borderColor = 'red';\n                isValid = false;\n            } else {\n                input.style.borderColor = '#ccc';\n            }\n        }\n    });\n    return isValid;\n}\n\nfunction initializePeople() {\n    whitePeople = Array.from({ length: gridSize * gridSize }, () => ({ \n        arrests: 0, \n        sentenceServed: 0, \n        sentenceRemaining: 0,\n        x: Math.random(),\n        y: Math.random()\n    }));\n    blackPeople = Array.from({ length: gridSize * gridSize }, () => ({ \n        arrests: 0, \n        sentenceServed: 0, \n        sentenceRemaining: 0,\n        x: Math.random(),\n        y: Math.random()\n    }));\n}\n\nfunction drawGrid(gridElement, people, isWhite) {\n    gridElement.innerHTML = '';\n    people.forEach(person => {\n        if (person.arrests > 0) {\n            const dot = document.createElement('div');\n            dot.className = `dot ${isWhite ? 'white-dot' : 'black-dot'}`;\n            const baseSize = 8;\n            const dotSize = baseSize + (person.arrests - 1) * 4;\n            dot.style.width = `${dotSize}px`;\n            dot.style.height = `${dotSize}px`;\n            dot.style.left = `${person.x * 100}%`;\n            dot.style.top = `${person.y * 100}%`;\n            gridElement.appendChild(dot);\n        }\n    });\n}\n\nfunction getSentence(arrestCount) {\n    const avgFirst = parseFloat(avgFirstInput.value);\n    const avgSecond = parseFloat(avgSecondInput.value);\n    const avgThird = parseFloat(avgThirdInput.value);\n    if (arrestCount === 1) return avgFirst;\n    if (arrestCount === 2) return avgSecond;\n    return avgThird;\n}\n\nfunction simulateArrests(people, arrestRate) {\n    const eligiblePeople = people.filter(person => person.sentenceRemaining <= 0);\n    const totalEligible = eligiblePeople.length;\n    const expectedArrests = Math.round(totalEligible * arrestRate);\n    \n    for (let i = 0; i < expectedArrests; i++) {\n        if (eligiblePeople.length === 0) break;\n        \n        const randomIndex = Math.floor(Math.random() * eligiblePeople.length);\n        const selectedPerson = eligiblePeople[randomIndex];\n        \n        selectedPerson.arrests++;\n        const sentence = getSentence(selectedPerson.arrests);\n        selectedPerson.sentenceRemaining = sentence;\n        \n        eligiblePeople.splice(randomIndex, 1);\n    }\n}\n\nfunction updateSentences(people) {\n    people.forEach(person => {\n        if (person.sentenceRemaining > 0) {\n            person.sentenceServed++;\n            person.sentenceRemaining--;\n        }\n    });\n}\n\nfunction getChartOptions(titleText) {\n    return {\n        responsive: true,\n        maintainAspectRatio: false,\n        interaction: {\n            intersect: false,\n            mode: 'index'\n        },\n        plugins: {\n            title: {\n                display: true,\n                text: titleText,\n                padding: {top: 10, bottom: 30},\n                font: {\n                    size: 18,\n                    weight: '600',\n                    family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                },\n                color: '#2c3e50'\n            },\n            legend: {\n                position: 'top',\n                align: 'center',\n                labels: {\n                    padding: 25,\n                    usePointStyle: true,\n                    pointStyle: 'circle',\n                    font: {\n                        size: 13,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                }\n            },\n            tooltip: {\n                backgroundColor: 'rgba(255, 255, 255, 0.95)',\n                titleColor: '#2c3e50',\n                titleFont: {\n                    size: 14,\n                    weight: '600',\n                    family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                },\n                bodyColor: '#34495e',\n                bodyFont: {\n                    size: 13,\n                    family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                },\n                borderColor: 'rgba(0,0,0,0.1)',\n                borderWidth: 1,\n                padding: 12,\n                cornerRadius: 6,\n                displayColors: true,\n                boxWidth: 8,\n                boxHeight: 8,\n                callbacks: {\n                    label: (context) => {\n                        const dataset = context.dataset;\n                        const value = context.parsed.y;\n                        let label = `${dataset.label}: ${value.toFixed(1)} years`;\n                        \n                        if (dataset.errorBars && dataset.errorBars.plus) {\n                            const stdDev = dataset.errorBars.plus[context.dataIndex];\n                            if (stdDev > 0) {\n                                label += ` ±${stdDev.toFixed(1)}`;\n                            }\n                        }\n                        \n                        return label;\n                    }\n                }\n            }\n        },\n        scales: {\n            y: {\n                beginAtZero: true,\n                title: {\n                    display: true,\n                    text: 'Cumulative Sentence Years',\n                    padding: {top: 15, bottom: 15},\n                    font: {\n                        size: 14,\n                        weight: '600',\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                },\n                ticks: {\n                    font: {\n                        size: 12,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#34495e',\n                    padding: 8\n                },\n                grid: {\n                    color: 'rgba(0,0,0,0.05)',\n                    drawBorder: false\n                }\n            },\n            x: {\n                title: {\n                    display: true,\n                    text: 'Simulation Year',\n                    padding: {top: 15, bottom: 15},\n                    font: {\n                        size: 14,\n                        weight: '600',\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                },\n                ticks: {\n                    font: {\n                        size: 12,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#34495e',\n                    padding: 8\n                },\n                grid: {\n                    color: 'rgba(0,0,0,0.05)',\n                    drawBorder: false\n                }\n            }\n        }\n    };\n}\n\nfunction runSimulation() {\n    if (!validateInputs()) {\n        alert('Please check input values. Arrest rates must be between 0-100%, sentences between 0-10 years.');\n        return;\n    }\n\n    initializePeople();\n    const whiteRate = parseFloat(whiteRateInput.value) / 100;\n    const blackRate = parseFloat(blackRateInput.value) / 100;\n    let whiteCumulativeSentences = [];\n    let blackCumulativeSentences = [];\n\n    for (let year = 0; year < 20; year++) {\n        simulateArrests(whitePeople, whiteRate);\n        simulateArrests(blackPeople, blackRate);\n        updateSentences(whitePeople);\n        updateSentences(blackPeople);\n\n        const totalWhiteSentences = whitePeople.reduce((sum, person) => sum + person.sentenceServed, 0);\n        const totalBlackSentences = blackPeople.reduce((sum, person) => sum + person.sentenceServed, 0);\n        whiteCumulativeSentences.push(totalWhiteSentences);\n        blackCumulativeSentences.push(totalBlackSentences);\n\n        drawGrid(whiteGrid, whitePeople, true);\n        drawGrid(blackGrid, blackPeople, false);\n    }\n\n    renderSingleSimChart(whiteCumulativeSentences, blackCumulativeSentences);\n}\n\nfunction renderSingleSimChart(whiteData, blackData) {\n    if (singleChart) {\n        singleChart.destroy();\n    }\n\n    const labels = Array.from({ length: 20 }, (_, i) => `Year ${i + 1}`);\n    \n    singleChart = new Chart(singleChartCtx, {\n        type: 'line',\n        data: {\n            labels: labels,\n            datasets: [{\n                label: 'White Population',\n                data: whiteData,\n                borderColor: '#1976D2',\n                borderWidth: 2.5,\n                tension: 0.3,\n                pointRadius: 4,\n                pointHoverRadius: 6,\n                pointBackgroundColor: '#1976D2',\n                pointBorderColor: '#fff',\n                pointBorderWidth: 2,\n                pointHoverBackgroundColor: '#1976D2',\n                pointHoverBorderColor: '#fff',\n                pointHoverBorderWidth: 2,\n                fill: false\n            }, {\n                label: 'Black Population',\n                data: blackData,\n                borderColor: '#D32F2F',\n                borderWidth: 2.5,\n                tension: 0.3,\n                pointRadius: 4,\n                pointHoverRadius: 6,\n                pointBackgroundColor: '#D32F2F',\n                pointBorderColor: '#fff',\n                pointBorderWidth: 2,\n                pointHoverBackgroundColor: '#D32F2F',\n                pointHoverBorderColor: '#fff',\n                pointHoverBorderWidth: 2,\n                fill: false\n            }]\n        },\n        options: getChartOptions('Single Simulation Results')\n    });\n}\n\nfunction calculateStats(simulations) {\n    const timePoints = simulations[0].length;\n    const means = Array(timePoints).fill(0);\n    const stdDevs = Array(timePoints).fill(0);\n    \n    // Calculate means for each time point\n    for (let t = 0; t < timePoints; t++) {\n        means[t] = simulations.reduce((sum, sim) => sum + sim[t], 0) / simulations.length;\n    }\n    \n    // Calculate standard deviations for each time point\n    for (let t = 0; t < timePoints; t++) {\n        const squaredDiffs = simulations.map(sim => Math.pow(sim[t] - means[t], 2));\n        const variance = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / simulations.length;\n        stdDevs[t] = Math.sqrt(variance);\n    }\n    \n    return { means, stdDevs };\n}\n\nfunction runMultipleSimulations() {\n    if (!validateInputs()) {\n        alert('Please check input values. Arrest rates must be between 0-100%, sentences between 0-10 years.');\n        return;\n    }\n\n    const numSimulations = 1000;\n    const whiteSimulations = [];\n    const blackSimulations = [];\n\n    for (let i = 0; i < numSimulations; i++) {\n        initializePeople();\n        const whiteRate = parseFloat(whiteRateInput.value) / 100;\n        const blackRate = parseFloat(blackRateInput.value) / 100;\n        let whiteCumulativeSentences = [];\n        let blackCumulativeSentences = [];\n\n        for (let year = 0; year < 20; year++) {\n            simulateArrests(whitePeople, whiteRate);\n            simulateArrests(blackPeople, blackRate);\n            updateSentences(whitePeople);\n            updateSentences(blackPeople);\n\n            const totalWhiteSentences = whitePeople.reduce((sum, person) => sum + person.sentenceServed, 0);\n            const totalBlackSentences = blackPeople.reduce((sum, person) => sum + person.sentenceServed, 0);\n            whiteCumulativeSentences.push(totalWhiteSentences);\n            blackCumulativeSentences.push(totalBlackSentences);\n        }\n\n        whiteSimulations.push(whiteCumulativeSentences);\n        blackSimulations.push(blackCumulativeSentences);\n    }\n\n    const whiteStats = calculateStats(whiteSimulations);\n    const blackStats = calculateStats(blackSimulations);\n\n    renderMultipleSimsChart(whiteStats, blackStats);\n}\n\n// Define custom plugin for ratio text\nconst ratioTextPlugin = {\n    id: 'ratioText',\n    beforeDraw: (chart, args, options) => {\n        const {ctx, chartArea: {left, top, right, bottom}} = chart;\n        \n        if (!options.text) return;\n        \n        // Save context state\n        ctx.save();\n        \n        // Set text style\n        ctx.font = '16px Arial, \"Helvetica Neue\", sans-serif';\n        ctx.fillStyle = '#2c3e50';\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'top';\n        \n        // Calculate position (5% from left, 5% from top)\n        const x = left + (right - left) * 0.05;\n        const y = top + (bottom - top) * 0.05;\n        \n        // Draw background\n        const textLines = options.text.split('\\n');\n        const lineHeight = 28;\n        const padding = 20;\n        const textWidth = Math.max(...textLines.map(line => ctx.measureText(line).width));\n        \n        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n        ctx.fillRect(\n            x - padding,\n            y - padding,\n            textWidth + padding * 2,\n            (textLines.length * lineHeight) + padding * 2\n        );\n        \n        // Draw text\n        ctx.fillStyle = '#2c3e50';\n        textLines.forEach((line, i) => {\n            ctx.fillText(line, x, y + (i * lineHeight));\n        });\n        \n        // Restore context state\n        ctx.restore();\n    }\n};\n\n// Register the plugin\nChart.register(ratioTextPlugin);\n\nfunction renderMultipleSimsChart(whiteStats, blackStats) {\n    if (multipleChart) {\n        multipleChart.destroy();\n    }\n\n    const labels = Array.from({ length: 20 }, (_, i) => `Year ${i + 1}`);\n    \n    // Calculate black-to-white ratio at year 20\n    const blackToWhiteRatio = blackStats.means[19] / whiteStats.means[19];\n    const ratioText = `For every year a white person spends incarcerated\\nfor criminal conduct, a black person engaging in\\nthe same conduct spends ${blackToWhiteRatio.toFixed(1)} years\\nincarcerated.`;\n    \n    multipleChart = new Chart(multipleChartCtx, {\n        type: 'line',\n        data: {\n            labels: labels,\n            datasets: [{\n                label: 'White Population',\n                data: whiteStats.means,\n                borderColor: '#1976D2',\n                borderWidth: 2.5,\n                tension: 0.3,\n                pointRadius: 4,\n                pointHoverRadius: 6,\n                pointBackgroundColor: '#1976D2',\n                pointBorderColor: '#fff',\n                pointBorderWidth: 2,\n                pointHoverBackgroundColor: '#1976D2',\n                pointHoverBorderColor: '#fff',\n                pointHoverBorderWidth: 2,\n                fill: false,\n                errorBars: {\n                    plus: whiteStats.stdDevs,\n                    minus: whiteStats.stdDevs,\n                    color: 'rgba(25, 118, 210, 0.3)'\n                }\n            }, {\n                label: 'Black Population',\n                data: blackStats.means,\n                borderColor: '#D32F2F',\n                borderWidth: 2.5,\n                tension: 0.3,\n                pointRadius: 4,\n                pointHoverRadius: 6,\n                pointBackgroundColor: '#D32F2F',\n                pointBorderColor: '#fff',\n                pointHoverBackgroundColor: '#D32F2F',\n                pointHoverBorderColor: '#fff',\n                pointHoverBorderWidth: 2,\n                fill: false,\n                errorBars: {\n                    plus: blackStats.stdDevs,\n                    minus: blackStats.stdDevs,\n                    color: 'rgba(211, 47, 47, 0.3)'\n                }\n            }]\n        },\n        options: {\n            ...getChartOptions('Multiple Simulations Results (with Standard Deviation)'),\n            plugins: {\n                ...getChartOptions('').plugins,\n                ratioText: {\n                    text: ratioText\n                }\n            }\n        }\n    });\n}\n\n// Add event listeners\nrunSimulationButton.addEventListener('click', () => {\n    runSimulation();\n    drawGrid(whiteGrid, whitePeople, true);\n    drawGrid(blackGrid, blackPeople, false);\n});\n\ndocument.getElementById('run_multiple_simulations').addEventListener('click', () => {\n    runMultipleSimulations();\n});\n\n// Initialize with single simulation\nrunSimulation();\n"],"names":["singleChart","multipleChart","whiteRateInput","document","getElementById","blackRateInput","avgFirstInput","avgSecondInput","avgThirdInput","runSimulationButton","whiteGrid","blackGrid","singleChartCanvas","multipleChartCanvas","singleChartCtx","getContext","multipleChartCtx","whitePeople","blackPeople","validateInputs","isValid","inputs","forEach","input","value","parseFloat","id","includes","style","borderColor","initializePeople","Array","from","length","gridSize","arrests","sentenceServed","sentenceRemaining","x","Math","random","y","drawGrid","gridElement","people","isWhite","innerHTML","person","dot","createElement","className","dotSize","baseSize","width","height","left","top","appendChild","simulateArrests","arrestRate","eligiblePeople","filter","expectedArrests","round","totalEligible","i","randomIndex","floor","selectedPerson","sentence","getSentence","arrestCount","avgFirst","avgSecond","avgThird","splice","updateSentences","getChartOptions","titleText","responsive","maintainAspectRatio","interaction","intersect","mode","plugins","title","display","text","padding","bottom","font","size","weight","family","color","legend","position","align","labels","usePointStyle","pointStyle","tooltip","backgroundColor","titleColor","titleFont","bodyColor","bodyFont","borderWidth","cornerRadius","displayColors","boxWidth","boxHeight","callbacks","label","context","dataset","parsed","toFixed","errorBars","plus","stdDev","dataIndex","scales","beginAtZero","ticks","grid","drawBorder","runSimulation","whiteData","blackData","alert","whiteRate","blackRate","whiteCumulativeSentences","blackCumulativeSentences","year","totalWhiteSentences","reduce","sum","totalBlackSentences","push","destroy","Chart","type","data","_","datasets","tension","pointRadius","pointHoverRadius","pointBackgroundColor","pointBorderColor","pointBorderWidth","pointHoverBackgroundColor","pointHoverBorderColor","pointHoverBorderWidth","fill","options","calculateStats","simulations","timePoints","means","stdDevs","t","sim","variance","squaredDiffs","map","pow","diff","sqrt","register","beforeDraw","chart","args","ctx","chartArea","right","save","fillStyle","textAlign","textBaseline","textLines","split","textWidth","max","line","measureText","fillRect","fillText","restore","addEventListener","runMultipleSimulations","whiteSimulations","blackSimulations","renderMultipleSimsChart","whiteStats","blackStats","blackToWhiteRatio","ratioText","minus"],"version":3,"file":"index.21f70b48.js.map"}