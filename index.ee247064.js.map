{"mappings":"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","sources":["<anon>","simulation.js"],"sourcesContent":["const whiteRateInput = document.getElementById('white_rate');\nconst blackRateInput = document.getElementById('black_rate');\nconst avgFirstInput = document.getElementById('avg_first');\nconst avgSecondInput = document.getElementById('avg_second');\nconst avgThirdInput = document.getElementById('avg_third');\nconst runSimulationButton = document.getElementById('run_simulation');\nconst whiteGrid = document.getElementById('white_grid');\nconst blackGrid = document.getElementById('black_grid');\n// Chart Elements\nconst singleChartCanvas = document.getElementById('single_sim_chart');\nconst multipleChartCanvas = document.getElementById('multiple_sims_chart');\nconst singleChartCtx = singleChartCanvas.getContext('2d');\nconst multipleChartCtx = multipleChartCanvas.getContext('2d');\n// Tab Elements\nconst tabButtons = document.querySelectorAll('.tab-button');\nconst tabPanels = document.querySelectorAll('.tab-panel');\n// State Variables\nconst gridSize = 10;\nlet whitePeople = [];\nlet blackPeople = [];\nlet singleChart;\nlet multipleChart;\n// Tab Switching\nfunction switchTab(targetTab) {\n    tabButtons.forEach((button)=>{\n        button.classList.toggle('active', button.dataset.tab === targetTab);\n    });\n    tabPanels.forEach((panel)=>{\n        panel.classList.toggle('active', panel.id === `${targetTab}-simulation`);\n    });\n}\ntabButtons.forEach((button)=>{\n    button.addEventListener('click', ()=>switchTab(button.dataset.tab));\n});\n// Input validation with visual feedback\nfunction validateInputs() {\n    const inputs = [\n        whiteRateInput,\n        blackRateInput,\n        avgFirstInput,\n        avgSecondInput,\n        avgThirdInput\n    ];\n    let isValid = true;\n    inputs.forEach((input)=>{\n        const value = parseFloat(input.value);\n        const wrapper = input.closest('.input-wrapper');\n        wrapper.classList.remove('error');\n        wrapper.removeAttribute('data-error');\n        if (input.id.includes('rate')) {\n            if (isNaN(value)) {\n                wrapper.classList.add('error');\n                wrapper.setAttribute('data-error', 'Please enter a valid number');\n                isValid = false;\n            } else if (value < 0 || value > 100) {\n                wrapper.classList.add('error');\n                wrapper.setAttribute('data-error', 'Must be between 0-100%');\n                isValid = false;\n            }\n        } else {\n            if (isNaN(value)) {\n                wrapper.classList.add('error');\n                wrapper.setAttribute('data-error', 'Please enter a valid number');\n                isValid = false;\n            } else if (value < 0 || value > 10) {\n                wrapper.classList.add('error');\n                wrapper.setAttribute('data-error', 'Must be between 0-10 years');\n                isValid = false;\n            }\n        }\n    });\n    return isValid;\n}\nfunction initializePeople() {\n    whitePeople = Array.from({\n        length: gridSize * gridSize\n    }, ()=>({\n            arrests: 0,\n            sentenceServed: 0,\n            sentenceRemaining: 0,\n            x: Math.random(),\n            y: Math.random()\n        }));\n    blackPeople = Array.from({\n        length: gridSize * gridSize\n    }, ()=>({\n            arrests: 0,\n            sentenceServed: 0,\n            sentenceRemaining: 0,\n            x: Math.random(),\n            y: Math.random()\n        }));\n}\nfunction drawGrid(gridElement, people, isWhite) {\n    gridElement.innerHTML = '';\n    people.forEach((person)=>{\n        if (person.arrests > 0) {\n            const dot = document.createElement('div');\n            dot.className = `dot ${isWhite ? 'white-dot' : 'black-dot'}`;\n            const baseSize = 8;\n            const dotSize = baseSize + (person.arrests - 1) * 4;\n            dot.style.width = `${dotSize}px`;\n            dot.style.height = `${dotSize}px`;\n            dot.style.left = `${person.x * 100}%`;\n            dot.style.top = `${person.y * 100}%`;\n            gridElement.appendChild(dot);\n        }\n    });\n}\nfunction getSentence(arrestCount) {\n    const avgFirst = parseFloat(avgFirstInput.value);\n    const avgSecond = parseFloat(avgSecondInput.value);\n    const avgThird = parseFloat(avgThirdInput.value);\n    if (arrestCount === 1) return avgFirst;\n    if (arrestCount === 2) return avgSecond;\n    return avgThird;\n}\nfunction simulateArrests(people, arrestRate) {\n    const eligiblePeople = people.filter((person)=>person.sentenceRemaining <= 0);\n    const totalEligible = eligiblePeople.length;\n    const expectedArrests = Math.round(totalEligible * arrestRate);\n    for(let i = 0; i < expectedArrests; i++){\n        if (eligiblePeople.length === 0) break;\n        const randomIndex = Math.floor(Math.random() * eligiblePeople.length);\n        const selectedPerson = eligiblePeople[randomIndex];\n        selectedPerson.arrests++;\n        const sentence = getSentence(selectedPerson.arrests);\n        selectedPerson.sentenceRemaining = sentence;\n        eligiblePeople.splice(randomIndex, 1);\n    }\n}\nfunction updateSentences(people) {\n    people.forEach((person)=>{\n        if (person.sentenceRemaining > 0) {\n            person.sentenceServed++;\n            person.sentenceRemaining--;\n        }\n    });\n}\nfunction getChartOptions(titleText) {\n    return {\n        responsive: true,\n        maintainAspectRatio: true,\n        interaction: {\n            intersect: false,\n            mode: 'index'\n        },\n        plugins: {\n            title: {\n                display: false // Title is now handled by HTML\n            },\n            legend: {\n                position: 'top',\n                align: 'center',\n                labels: {\n                    padding: 20,\n                    usePointStyle: true,\n                    pointStyle: 'circle',\n                    font: {\n                        size: 13,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                }\n            },\n            tooltip: {\n                backgroundColor: 'rgba(255, 255, 255, 0.95)',\n                titleColor: '#2c3e50',\n                titleFont: {\n                    size: 14,\n                    weight: '600',\n                    family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                },\n                bodyColor: '#34495e',\n                bodyFont: {\n                    size: 13,\n                    family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                },\n                borderColor: 'rgba(0,0,0,0.1)',\n                borderWidth: 1,\n                padding: 12,\n                cornerRadius: 6,\n                displayColors: true,\n                boxWidth: 8,\n                boxHeight: 8,\n                callbacks: {\n                    label: (context)=>{\n                        const dataset = context.dataset;\n                        const value = context.parsed.y;\n                        let label = `${dataset.label}: ${value.toFixed(1)} years`;\n                        if (dataset.errorBars && dataset.errorBars.plus) {\n                            const stdDev = dataset.errorBars.plus[context.dataIndex];\n                            if (stdDev > 0) label += ` \\xb1${stdDev.toFixed(1)}`;\n                        }\n                        return label;\n                    }\n                }\n            }\n        },\n        scales: {\n            y: {\n                beginAtZero: true,\n                title: {\n                    display: true,\n                    text: 'Cumulative Sentence Years',\n                    padding: {\n                        top: 15,\n                        bottom: 15\n                    },\n                    font: {\n                        size: 14,\n                        weight: '600',\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                },\n                ticks: {\n                    font: {\n                        size: 12,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#34495e',\n                    padding: 8\n                },\n                grid: {\n                    color: 'rgba(0,0,0,0.05)',\n                    drawBorder: false\n                }\n            },\n            x: {\n                title: {\n                    display: true,\n                    text: 'Simulation Year',\n                    padding: {\n                        top: 15,\n                        bottom: 15\n                    },\n                    font: {\n                        size: 14,\n                        weight: '600',\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                },\n                ticks: {\n                    font: {\n                        size: 12,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#34495e',\n                    padding: 8\n                },\n                grid: {\n                    color: 'rgba(0,0,0,0.05)',\n                    drawBorder: false\n                }\n            }\n        }\n    };\n}\nasync function runSimulation() {\n    if (!validateInputs()) {\n        alert('Please check input values. Arrest rates must be between 0-100%, sentences between 0-10 years.');\n        return;\n    }\n    runSimulationButton.classList.add('loading');\n    runSimulationButton.disabled = true;\n    try {\n        initializePeople();\n        const whiteRate = parseFloat(whiteRateInput.value) / 100;\n        const blackRate = parseFloat(blackRateInput.value) / 100;\n        let whiteCumulativeSentences = [];\n        let blackCumulativeSentences = [];\n        for(let year = 0; year < 20; year++){\n            simulateArrests(whitePeople, whiteRate);\n            simulateArrests(blackPeople, blackRate);\n            updateSentences(whitePeople);\n            updateSentences(blackPeople);\n            const totalWhiteSentences = whitePeople.reduce((sum, person)=>sum + person.sentenceServed, 0);\n            const totalBlackSentences = blackPeople.reduce((sum, person)=>sum + person.sentenceServed, 0);\n            whiteCumulativeSentences.push(totalWhiteSentences);\n            blackCumulativeSentences.push(totalBlackSentences);\n            drawGrid(whiteGrid, whitePeople, true);\n            drawGrid(blackGrid, blackPeople, false);\n            // Add small delay for visual feedback\n            if (year % 5 === 0) await new Promise((resolve)=>setTimeout(resolve, 50));\n        }\n        renderSingleSimChart(whiteCumulativeSentences, blackCumulativeSentences);\n    } finally{\n        runSimulationButton.classList.remove('loading');\n        runSimulationButton.disabled = false;\n    }\n}\nfunction renderSingleSimChart(whiteData, blackData) {\n    if (singleChart) singleChart.destroy();\n    const labels = Array.from({\n        length: 20\n    }, (_, i)=>`Year ${i + 1}`);\n    singleChart = new Chart(singleChartCtx, {\n        type: 'line',\n        data: {\n            labels: labels,\n            datasets: [\n                {\n                    label: 'White Population',\n                    data: whiteData,\n                    borderColor: '#1976D2',\n                    borderWidth: 2.5,\n                    tension: 0.3,\n                    pointRadius: 4,\n                    pointHoverRadius: 6,\n                    pointBackgroundColor: '#1976D2',\n                    pointBorderColor: '#fff',\n                    pointBorderWidth: 2,\n                    pointHoverBackgroundColor: '#1976D2',\n                    pointHoverBorderColor: '#fff',\n                    pointHoverBorderWidth: 2,\n                    fill: false\n                },\n                {\n                    label: 'Black Population',\n                    data: blackData,\n                    borderColor: '#D32F2F',\n                    borderWidth: 2.5,\n                    tension: 0.3,\n                    pointRadius: 4,\n                    pointHoverRadius: 6,\n                    pointBackgroundColor: '#D32F2F',\n                    pointBorderColor: '#fff',\n                    pointBorderWidth: 2,\n                    pointHoverBackgroundColor: '#D32F2F',\n                    pointHoverBorderColor: '#fff',\n                    pointHoverBorderWidth: 2,\n                    fill: false\n                }\n            ]\n        },\n        options: getChartOptions('Single Simulation Results')\n    });\n}\nfunction calculateStats(simulations) {\n    const timePoints = simulations[0].length;\n    const means = Array(timePoints).fill(0);\n    const stdDevs = Array(timePoints).fill(0);\n    // Calculate means for each time point\n    for(let t = 0; t < timePoints; t++)means[t] = simulations.reduce((sum, sim)=>sum + sim[t], 0) / simulations.length;\n    // Calculate standard deviations for each time point\n    for(let t = 0; t < timePoints; t++){\n        const squaredDiffs = simulations.map((sim)=>Math.pow(sim[t] - means[t], 2));\n        const variance = squaredDiffs.reduce((sum, diff)=>sum + diff, 0) / simulations.length;\n        stdDevs[t] = Math.sqrt(variance);\n    }\n    return {\n        means,\n        stdDevs\n    };\n}\nasync function runMultipleSimulations() {\n    if (!validateInputs()) {\n        alert('Please check input values. Arrest rates must be between 0-100%, sentences between 0-10 years.');\n        return;\n    }\n    const multipleSimButton = document.getElementById('run_multiple_simulations');\n    multipleSimButton.classList.add('loading');\n    multipleSimButton.disabled = true;\n    try {\n        const numSimulations = 1000;\n        const whiteSimulations = [];\n        const blackSimulations = [];\n        for(let i = 0; i < numSimulations; i++){\n            initializePeople();\n            const whiteRate = parseFloat(whiteRateInput.value) / 100;\n            const blackRate = parseFloat(blackRateInput.value) / 100;\n            let whiteCumulativeSentences = [];\n            let blackCumulativeSentences = [];\n            for(let year = 0; year < 20; year++){\n                simulateArrests(whitePeople, whiteRate);\n                simulateArrests(blackPeople, blackRate);\n                updateSentences(whitePeople);\n                updateSentences(blackPeople);\n                const totalWhiteSentences = whitePeople.reduce((sum, person)=>sum + person.sentenceServed, 0);\n                const totalBlackSentences = blackPeople.reduce((sum, person)=>sum + person.sentenceServed, 0);\n                whiteCumulativeSentences.push(totalWhiteSentences);\n                blackCumulativeSentences.push(totalBlackSentences);\n            }\n            whiteSimulations.push(whiteCumulativeSentences);\n            blackSimulations.push(blackCumulativeSentences);\n            // Add progress feedback every 100 simulations\n            if (i % 100 === 0) await new Promise((resolve)=>setTimeout(resolve, 0));\n        }\n        const whiteStats = calculateStats(whiteSimulations);\n        const blackStats = calculateStats(blackSimulations);\n        renderMultipleSimsChart(whiteStats, blackStats);\n    } finally{\n        multipleSimButton.classList.remove('loading');\n        multipleSimButton.disabled = false;\n    }\n}\n// Define custom plugin for ratio text\nconst ratioTextPlugin = {\n    id: 'ratioText',\n    beforeDraw: (chart, args, options)=>{\n        const { ctx, chartArea: { left, top, right, bottom } } = chart;\n        if (!options.text) return;\n        // Save context state\n        ctx.save();\n        // Set text style\n        ctx.font = '16px Arial, \"Helvetica Neue\", sans-serif';\n        ctx.fillStyle = '#2c3e50';\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'top';\n        // Calculate position (5% from left, 5% from top)\n        const x = left + (right - left) * 0.05;\n        const y = top + (bottom - top) * 0.05;\n        // Draw background\n        const textLines = options.text.split('\\n');\n        const lineHeight = 28;\n        const padding = 20;\n        const textWidth = Math.max(...textLines.map((line)=>ctx.measureText(line).width));\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n        ctx.fillRect(x - padding, y - padding, textWidth + padding * 2, textLines.length * lineHeight + padding * 2);\n        // Draw text\n        ctx.fillStyle = '#2c3e50';\n        textLines.forEach((line, i)=>{\n            ctx.fillText(line, x, y + i * lineHeight);\n        });\n        // Restore context state\n        ctx.restore();\n    }\n};\n// Register the plugin\nChart.register(ratioTextPlugin);\nfunction renderMultipleSimsChart(whiteStats, blackStats) {\n    if (multipleChart) multipleChart.destroy();\n    const labels = Array.from({\n        length: 20\n    }, (_, i)=>`Year ${i + 1}`);\n    // Calculate black-to-white ratio at year 20\n    const blackToWhiteRatio = blackStats.means[19] / whiteStats.means[19];\n    const ratioText = `For every year a white person spends incarcerated\\nfor criminal conduct, a black person engaging in\\nthe same conduct spends ${blackToWhiteRatio.toFixed(1)} years\\nincarcerated.`;\n    multipleChart = new Chart(multipleChartCtx, {\n        type: 'line',\n        data: {\n            labels: labels,\n            datasets: [\n                {\n                    label: 'White Population',\n                    data: whiteStats.means,\n                    borderColor: '#1976D2',\n                    borderWidth: 2.5,\n                    tension: 0.3,\n                    pointRadius: 4,\n                    pointHoverRadius: 6,\n                    pointBackgroundColor: '#1976D2',\n                    pointBorderColor: '#fff',\n                    pointBorderWidth: 2,\n                    pointHoverBackgroundColor: '#1976D2',\n                    pointHoverBorderColor: '#fff',\n                    pointHoverBorderWidth: 2,\n                    fill: false,\n                    errorBars: {\n                        plus: whiteStats.stdDevs,\n                        minus: whiteStats.stdDevs,\n                        color: 'rgba(25, 118, 210, 0.3)'\n                    }\n                },\n                {\n                    label: 'Black Population',\n                    data: blackStats.means,\n                    borderColor: '#D32F2F',\n                    borderWidth: 2.5,\n                    tension: 0.3,\n                    pointRadius: 4,\n                    pointHoverRadius: 6,\n                    pointBackgroundColor: '#D32F2F',\n                    pointBorderColor: '#fff',\n                    pointHoverBackgroundColor: '#D32F2F',\n                    pointHoverBorderColor: '#fff',\n                    pointHoverBorderWidth: 2,\n                    fill: false,\n                    errorBars: {\n                        plus: blackStats.stdDevs,\n                        minus: blackStats.stdDevs,\n                        color: 'rgba(211, 47, 47, 0.3)'\n                    }\n                }\n            ]\n        },\n        options: getChartOptions('Multiple Simulations Results')\n    });\n}\n// Add event listeners\nrunSimulationButton.addEventListener('click', runSimulation);\ndocument.getElementById('run_multiple_simulations').addEventListener('click', runMultipleSimulations);\n// Initialize with single simulation\nrunSimulation();\n\n//# sourceMappingURL=index.ee247064.js.map\n","const whiteRateInput = document.getElementById('white_rate');\nconst blackRateInput = document.getElementById('black_rate');\nconst avgFirstInput = document.getElementById('avg_first');\nconst avgSecondInput = document.getElementById('avg_second');\nconst avgThirdInput = document.getElementById('avg_third');\nconst runSimulationButton = document.getElementById('run_simulation');\nconst whiteGrid = document.getElementById('white_grid');\nconst blackGrid = document.getElementById('black_grid');\n\n// Chart Elements\nconst singleChartCanvas = document.getElementById('single_sim_chart');\nconst multipleChartCanvas = document.getElementById('multiple_sims_chart');\nconst singleChartCtx = singleChartCanvas.getContext('2d');\nconst multipleChartCtx = multipleChartCanvas.getContext('2d');\n\n// Tab Elements\nconst tabButtons = document.querySelectorAll('.tab-button');\nconst tabPanels = document.querySelectorAll('.tab-panel');\n\n// State Variables\nconst gridSize = 10;\nlet whitePeople = [];\nlet blackPeople = [];\nlet singleChart;\nlet multipleChart;\n\n// Tab Switching\nfunction switchTab(targetTab) {\n    tabButtons.forEach(button => {\n        button.classList.toggle('active', button.dataset.tab === targetTab);\n    });\n    tabPanels.forEach(panel => {\n        panel.classList.toggle('active', panel.id === `${targetTab}-simulation`);\n    });\n}\n\ntabButtons.forEach(button => {\n    button.addEventListener('click', () => switchTab(button.dataset.tab));\n});\n\n// Input validation with visual feedback\nfunction validateInputs() {\n    const inputs = [whiteRateInput, blackRateInput, avgFirstInput, avgSecondInput, avgThirdInput];\n    let isValid = true;\n    inputs.forEach(input => {\n        const value = parseFloat(input.value);\n        const wrapper = input.closest('.input-wrapper');\n        wrapper.classList.remove('error');\n        wrapper.removeAttribute('data-error');\n        \n        if (input.id.includes('rate')) {\n            if (isNaN(value)) {\n                wrapper.classList.add('error');\n                wrapper.setAttribute('data-error', 'Please enter a valid number');\n                isValid = false;\n            } else if (value < 0 || value > 100) {\n                wrapper.classList.add('error');\n                wrapper.setAttribute('data-error', 'Must be between 0-100%');\n                isValid = false;\n            }\n        } else {\n            if (isNaN(value)) {\n                wrapper.classList.add('error');\n                wrapper.setAttribute('data-error', 'Please enter a valid number');\n                isValid = false;\n            } else if (value < 0 || value > 10) {\n                wrapper.classList.add('error');\n                wrapper.setAttribute('data-error', 'Must be between 0-10 years');\n                isValid = false;\n            }\n        }\n    });\n    return isValid;\n}\n\nfunction initializePeople() {\n    whitePeople = Array.from({ length: gridSize * gridSize }, () => ({ \n        arrests: 0, \n        sentenceServed: 0, \n        sentenceRemaining: 0,\n        x: Math.random(),\n        y: Math.random()\n    }));\n    blackPeople = Array.from({ length: gridSize * gridSize }, () => ({ \n        arrests: 0, \n        sentenceServed: 0, \n        sentenceRemaining: 0,\n        x: Math.random(),\n        y: Math.random()\n    }));\n}\n\nfunction drawGrid(gridElement, people, isWhite) {\n    gridElement.innerHTML = '';\n    people.forEach(person => {\n        if (person.arrests > 0) {\n            const dot = document.createElement('div');\n            dot.className = `dot ${isWhite ? 'white-dot' : 'black-dot'}`;\n            const baseSize = 8;\n            const dotSize = baseSize + (person.arrests - 1) * 4;\n            dot.style.width = `${dotSize}px`;\n            dot.style.height = `${dotSize}px`;\n            dot.style.left = `${person.x * 100}%`;\n            dot.style.top = `${person.y * 100}%`;\n            gridElement.appendChild(dot);\n        }\n    });\n}\n\nfunction getSentence(arrestCount) {\n    const avgFirst = parseFloat(avgFirstInput.value);\n    const avgSecond = parseFloat(avgSecondInput.value);\n    const avgThird = parseFloat(avgThirdInput.value);\n    if (arrestCount === 1) return avgFirst;\n    if (arrestCount === 2) return avgSecond;\n    return avgThird;\n}\n\nfunction simulateArrests(people, arrestRate) {\n    const eligiblePeople = people.filter(person => person.sentenceRemaining <= 0);\n    const totalEligible = eligiblePeople.length;\n    const expectedArrests = Math.round(totalEligible * arrestRate);\n    \n    for (let i = 0; i < expectedArrests; i++) {\n        if (eligiblePeople.length === 0) break;\n        \n        const randomIndex = Math.floor(Math.random() * eligiblePeople.length);\n        const selectedPerson = eligiblePeople[randomIndex];\n        \n        selectedPerson.arrests++;\n        const sentence = getSentence(selectedPerson.arrests);\n        selectedPerson.sentenceRemaining = sentence;\n        \n        eligiblePeople.splice(randomIndex, 1);\n    }\n}\n\nfunction updateSentences(people) {\n    people.forEach(person => {\n        if (person.sentenceRemaining > 0) {\n            person.sentenceServed++;\n            person.sentenceRemaining--;\n        }\n    });\n}\n\nfunction getChartOptions(titleText) {\n    return {\n        responsive: true,\n        maintainAspectRatio: true,\n        interaction: {\n            intersect: false,\n            mode: 'index'\n        },\n        plugins: {\n            title: {\n                display: false // Title is now handled by HTML\n            },\n            legend: {\n                position: 'top',\n                align: 'center',\n                labels: {\n                    padding: 20,\n                    usePointStyle: true,\n                    pointStyle: 'circle',\n                    font: {\n                        size: 13,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                }\n            },\n            tooltip: {\n                backgroundColor: 'rgba(255, 255, 255, 0.95)',\n                titleColor: '#2c3e50',\n                titleFont: {\n                    size: 14,\n                    weight: '600',\n                    family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                },\n                bodyColor: '#34495e',\n                bodyFont: {\n                    size: 13,\n                    family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                },\n                borderColor: 'rgba(0,0,0,0.1)',\n                borderWidth: 1,\n                padding: 12,\n                cornerRadius: 6,\n                displayColors: true,\n                boxWidth: 8,\n                boxHeight: 8,\n                callbacks: {\n                    label: (context) => {\n                        const dataset = context.dataset;\n                        const value = context.parsed.y;\n                        let label = `${dataset.label}: ${value.toFixed(1)} years`;\n                        \n                        if (dataset.errorBars && dataset.errorBars.plus) {\n                            const stdDev = dataset.errorBars.plus[context.dataIndex];\n                            if (stdDev > 0) {\n                                label += ` Â±${stdDev.toFixed(1)}`;\n                            }\n                        }\n                        \n                        return label;\n                    }\n                }\n            }\n        },\n        scales: {\n            y: {\n                beginAtZero: true,\n                title: {\n                    display: true,\n                    text: 'Cumulative Sentence Years',\n                    padding: {top: 15, bottom: 15},\n                    font: {\n                        size: 14,\n                        weight: '600',\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                },\n                ticks: {\n                    font: {\n                        size: 12,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#34495e',\n                    padding: 8\n                },\n                grid: {\n                    color: 'rgba(0,0,0,0.05)',\n                    drawBorder: false\n                }\n            },\n            x: {\n                title: {\n                    display: true,\n                    text: 'Simulation Year',\n                    padding: {top: 15, bottom: 15},\n                    font: {\n                        size: 14,\n                        weight: '600',\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#2c3e50'\n                },\n                ticks: {\n                    font: {\n                        size: 12,\n                        family: \"'Arial', 'Helvetica Neue', sans-serif\"\n                    },\n                    color: '#34495e',\n                    padding: 8\n                },\n                grid: {\n                    color: 'rgba(0,0,0,0.05)',\n                    drawBorder: false\n                }\n            }\n        }\n    };\n}\n\nasync function runSimulation() {\n    if (!validateInputs()) {\n        alert('Please check input values. Arrest rates must be between 0-100%, sentences between 0-10 years.');\n        return;\n    }\n\n    runSimulationButton.classList.add('loading');\n    runSimulationButton.disabled = true;\n\n    try {\n        initializePeople();\n        const whiteRate = parseFloat(whiteRateInput.value) / 100;\n        const blackRate = parseFloat(blackRateInput.value) / 100;\n        let whiteCumulativeSentences = [];\n        let blackCumulativeSentences = [];\n\n        for (let year = 0; year < 20; year++) {\n            simulateArrests(whitePeople, whiteRate);\n            simulateArrests(blackPeople, blackRate);\n            updateSentences(whitePeople);\n            updateSentences(blackPeople);\n\n            const totalWhiteSentences = whitePeople.reduce((sum, person) => sum + person.sentenceServed, 0);\n            const totalBlackSentences = blackPeople.reduce((sum, person) => sum + person.sentenceServed, 0);\n            whiteCumulativeSentences.push(totalWhiteSentences);\n            blackCumulativeSentences.push(totalBlackSentences);\n\n            drawGrid(whiteGrid, whitePeople, true);\n            drawGrid(blackGrid, blackPeople, false);\n\n            // Add small delay for visual feedback\n            if (year % 5 === 0) {\n                await new Promise(resolve => setTimeout(resolve, 50));\n            }\n        }\n\n        renderSingleSimChart(whiteCumulativeSentences, blackCumulativeSentences);\n    } finally {\n        runSimulationButton.classList.remove('loading');\n        runSimulationButton.disabled = false;\n    }\n}\n\nfunction renderSingleSimChart(whiteData, blackData) {\n    if (singleChart) {\n        singleChart.destroy();\n    }\n\n    const labels = Array.from({ length: 20 }, (_, i) => `Year ${i + 1}`);\n    \n    singleChart = new Chart(singleChartCtx, {\n        type: 'line',\n        data: {\n            labels: labels,\n            datasets: [{\n                label: 'White Population',\n                data: whiteData,\n                borderColor: '#1976D2',\n                borderWidth: 2.5,\n                tension: 0.3,\n                pointRadius: 4,\n                pointHoverRadius: 6,\n                pointBackgroundColor: '#1976D2',\n                pointBorderColor: '#fff',\n                pointBorderWidth: 2,\n                pointHoverBackgroundColor: '#1976D2',\n                pointHoverBorderColor: '#fff',\n                pointHoverBorderWidth: 2,\n                fill: false\n            }, {\n                label: 'Black Population',\n                data: blackData,\n                borderColor: '#D32F2F',\n                borderWidth: 2.5,\n                tension: 0.3,\n                pointRadius: 4,\n                pointHoverRadius: 6,\n                pointBackgroundColor: '#D32F2F',\n                pointBorderColor: '#fff',\n                pointBorderWidth: 2,\n                pointHoverBackgroundColor: '#D32F2F',\n                pointHoverBorderColor: '#fff',\n                pointHoverBorderWidth: 2,\n                fill: false\n            }]\n        },\n        options: getChartOptions('Single Simulation Results')\n    });\n}\n\nfunction calculateStats(simulations) {\n    const timePoints = simulations[0].length;\n    const means = Array(timePoints).fill(0);\n    const stdDevs = Array(timePoints).fill(0);\n    \n    // Calculate means for each time point\n    for (let t = 0; t < timePoints; t++) {\n        means[t] = simulations.reduce((sum, sim) => sum + sim[t], 0) / simulations.length;\n    }\n    \n    // Calculate standard deviations for each time point\n    for (let t = 0; t < timePoints; t++) {\n        const squaredDiffs = simulations.map(sim => Math.pow(sim[t] - means[t], 2));\n        const variance = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / simulations.length;\n        stdDevs[t] = Math.sqrt(variance);\n    }\n    \n    return { means, stdDevs };\n}\n\nasync function runMultipleSimulations() {\n    if (!validateInputs()) {\n        alert('Please check input values. Arrest rates must be between 0-100%, sentences between 0-10 years.');\n        return;\n    }\n\n    const multipleSimButton = document.getElementById('run_multiple_simulations');\n    multipleSimButton.classList.add('loading');\n    multipleSimButton.disabled = true;\n\n    try {\n        const numSimulations = 1000;\n        const whiteSimulations = [];\n        const blackSimulations = [];\n\n        for (let i = 0; i < numSimulations; i++) {\n            initializePeople();\n            const whiteRate = parseFloat(whiteRateInput.value) / 100;\n            const blackRate = parseFloat(blackRateInput.value) / 100;\n            let whiteCumulativeSentences = [];\n            let blackCumulativeSentences = [];\n\n            for (let year = 0; year < 20; year++) {\n                simulateArrests(whitePeople, whiteRate);\n                simulateArrests(blackPeople, blackRate);\n                updateSentences(whitePeople);\n                updateSentences(blackPeople);\n\n                const totalWhiteSentences = whitePeople.reduce((sum, person) => sum + person.sentenceServed, 0);\n                const totalBlackSentences = blackPeople.reduce((sum, person) => sum + person.sentenceServed, 0);\n                whiteCumulativeSentences.push(totalWhiteSentences);\n                blackCumulativeSentences.push(totalBlackSentences);\n            }\n\n            whiteSimulations.push(whiteCumulativeSentences);\n            blackSimulations.push(blackCumulativeSentences);\n\n            // Add progress feedback every 100 simulations\n            if (i % 100 === 0) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n            }\n        }\n\n        const whiteStats = calculateStats(whiteSimulations);\n        const blackStats = calculateStats(blackSimulations);\n\n        renderMultipleSimsChart(whiteStats, blackStats);\n    } finally {\n        multipleSimButton.classList.remove('loading');\n        multipleSimButton.disabled = false;\n    }\n}\n\n// Define custom plugin for ratio text\nconst ratioTextPlugin = {\n    id: 'ratioText',\n    beforeDraw: (chart, args, options) => {\n        const {ctx, chartArea: {left, top, right, bottom}} = chart;\n        \n        if (!options.text) return;\n        \n        // Save context state\n        ctx.save();\n        \n        // Set text style\n        ctx.font = '16px Arial, \"Helvetica Neue\", sans-serif';\n        ctx.fillStyle = '#2c3e50';\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'top';\n        \n        // Calculate position (5% from left, 5% from top)\n        const x = left + (right - left) * 0.05;\n        const y = top + (bottom - top) * 0.05;\n        \n        // Draw background\n        const textLines = options.text.split('\\n');\n        const lineHeight = 28;\n        const padding = 20;\n        const textWidth = Math.max(...textLines.map(line => ctx.measureText(line).width));\n        \n        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n        ctx.fillRect(\n            x - padding,\n            y - padding,\n            textWidth + padding * 2,\n            (textLines.length * lineHeight) + padding * 2\n        );\n        \n        // Draw text\n        ctx.fillStyle = '#2c3e50';\n        textLines.forEach((line, i) => {\n            ctx.fillText(line, x, y + (i * lineHeight));\n        });\n        \n        // Restore context state\n        ctx.restore();\n    }\n};\n\n// Register the plugin\nChart.register(ratioTextPlugin);\n\nfunction renderMultipleSimsChart(whiteStats, blackStats) {\n    if (multipleChart) {\n        multipleChart.destroy();\n    }\n\n    const labels = Array.from({ length: 20 }, (_, i) => `Year ${i + 1}`);\n    \n    // Calculate black-to-white ratio at year 20\n    const blackToWhiteRatio = blackStats.means[19] / whiteStats.means[19];\n    const ratioText = `For every year a white person spends incarcerated\\nfor criminal conduct, a black person engaging in\\nthe same conduct spends ${blackToWhiteRatio.toFixed(1)} years\\nincarcerated.`;\n    \n    multipleChart = new Chart(multipleChartCtx, {\n        type: 'line',\n        data: {\n            labels: labels,\n            datasets: [{\n                label: 'White Population',\n                data: whiteStats.means,\n                borderColor: '#1976D2',\n                borderWidth: 2.5,\n                tension: 0.3,\n                pointRadius: 4,\n                pointHoverRadius: 6,\n                pointBackgroundColor: '#1976D2',\n                pointBorderColor: '#fff',\n                pointBorderWidth: 2,\n                pointHoverBackgroundColor: '#1976D2',\n                pointHoverBorderColor: '#fff',\n                pointHoverBorderWidth: 2,\n                fill: false,\n                errorBars: {\n                    plus: whiteStats.stdDevs,\n                    minus: whiteStats.stdDevs,\n                    color: 'rgba(25, 118, 210, 0.3)'\n                }\n            }, {\n                label: 'Black Population',\n                data: blackStats.means,\n                borderColor: '#D32F2F',\n                borderWidth: 2.5,\n                tension: 0.3,\n                pointRadius: 4,\n                pointHoverRadius: 6,\n                pointBackgroundColor: '#D32F2F',\n                pointBorderColor: '#fff',\n                pointHoverBackgroundColor: '#D32F2F',\n                pointHoverBorderColor: '#fff',\n                pointHoverBorderWidth: 2,\n                fill: false,\n                errorBars: {\n                    plus: blackStats.stdDevs,\n                    minus: blackStats.stdDevs,\n                    color: 'rgba(211, 47, 47, 0.3)'\n                }\n            }]\n        },\n        options: getChartOptions('Multiple Simulations Results')\n    });\n}\n\n// Add event listeners\nrunSimulationButton.addEventListener('click', runSimulation);\ndocument.getElementById('run_multiple_simulations').addEventListener('click', runMultipleSimulations);\n\n// Initialize with single simulation\nrunSimulation();\n"],"names":["singleChart","multipleChart","whiteRateInput","document","getElementById","blackRateInput","avgFirstInput","avgSecondInput","avgThirdInput","runSimulationButton","whiteGrid","blackGrid","singleChartCanvas","multipleChartCanvas","singleChartCtx","getContext","multipleChartCtx","tabButtons","querySelectorAll","tabPanels","whitePeople","blackPeople","validateInputs","isValid","inputs","forEach","input","value","parseFloat","wrapper","closest","classList","remove","removeAttribute","id","includes","isNaN","add","setAttribute","initializePeople","Array","from","length","gridSize","arrests","sentenceServed","sentenceRemaining","x","Math","random","y","drawGrid","gridElement","people","isWhite","innerHTML","person","dot","createElement","className","dotSize","baseSize","style","width","height","left","top","appendChild","simulateArrests","arrestRate","eligiblePeople","filter","expectedArrests","round","totalEligible","i","randomIndex","floor","selectedPerson","sentence","getSentence","arrestCount","avgFirst","avgSecond","avgThird","splice","updateSentences","getChartOptions","titleText","responsive","maintainAspectRatio","interaction","intersect","mode","plugins","title","display","legend","position","align","labels","padding","usePointStyle","pointStyle","font","size","family","color","tooltip","backgroundColor","titleColor","titleFont","weight","bodyColor","bodyFont","borderColor","borderWidth","cornerRadius","displayColors","boxWidth","boxHeight","callbacks","label","context","dataset","parsed","toFixed","errorBars","plus","stdDev","dataIndex","scales","beginAtZero","text","bottom","ticks","grid","drawBorder","runSimulation","alert","disabled","whiteData","blackData","whiteRate","blackRate","whiteCumulativeSentences","blackCumulativeSentences","year","totalWhiteSentences","reduce","sum","totalBlackSentences","push","Promise","resolve","setTimeout","destroy","Chart","type","data","_","datasets","tension","pointRadius","pointHoverRadius","pointBackgroundColor","pointBorderColor","pointBorderWidth","pointHoverBackgroundColor","pointHoverBorderColor","pointHoverBorderWidth","fill","options","calculateStats","simulations","timePoints","means","stdDevs","t","sim","variance","squaredDiffs","map","pow","diff","sqrt","runMultipleSimulations","multipleSimButton","whiteSimulations","blackSimulations","whiteStats","blackStats","renderMultipleSimsChart","blackToWhiteRatio","minus","button","addEventListener","targetTab","tab","toggle","panel","register","beforeDraw","chart","args","ctx","chartArea","right","save","fillStyle","textAlign","textBaseline","textLines","split","textWidth","max","line","measureText","fillRect","fillText","restore"],"version":3,"file":"index.ee247064.js.map"}